import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
/** [[exist(element)]]=1 */
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

/** [[exist(element)]]>=1/2 */
private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
	PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement)
// For non-primitive type. Boolean types always must equivalent or cannot equivalent
{
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

pattern mustEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
// For non-primitive and Boolean primitive type
	find mustExist(problem,interpretation,a);
	find mustExist(problem,interpretation,b);
	a == b;
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 Required Patterns by TypeIndexer
//////////

private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1.1.2 primitive Type Indexers
//////////
// Currently unused. Refer primitive types as:
// > PrimitiveElement(element)
// specific types are referred as:
// > BooleanElement(variableName)
// > IntegerElement(variableName)
// > RealElement(variableName)
// > StringElement(variableName)
// And their value as
// > BooleanElement.value(variableName,value)
// > IntegerElement.value(variableName,value)
// > RealElement.value(variableName,value)
// > StringElement.value(variableName,value)
// Whether a value is set is defined by:
// > PrimitiveElement.valueSet(variableName,isFilled);

//////////
// 1.1.3 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Pseudostate class".
 */
private pattern mustInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pseudostate class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pseudostate class");
}

/**
 * An element may be an instance of type "Pseudostate class".
 */
private pattern mayInstanceOfPseudostate_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPseudostate_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPseudostate_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Vertex class".
 */
private pattern mustInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Vertex class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVertex_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Vertex class");
}

/**
 * An element may be an instance of type "Vertex class".
 */
private pattern mayInstanceOfVertex_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewVertex_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVertex_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Region class".
 */
private pattern mustInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Region class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegion_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Region class");
}

/**
 * An element may be an instance of type "Region class".
 */
private pattern mayInstanceOfRegion_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegion_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegion_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Transition class".
 */
private pattern mustInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Transition class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewTransition_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Transition class");
}

/**
 * An element may be an instance of type "Transition class".
 */
private pattern mayInstanceOfTransition_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewTransition_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfTransition_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statechart class".
 */
private pattern mustInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statechart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statechart class");
}

/**
 * An element may be an instance of type "Statechart class".
 */
private pattern mayInstanceOfStatechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatechart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatechart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Entry class".
 */
private pattern mustInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Entry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Entry class");
}

/**
 * An element may be an instance of type "Entry class".
 */
private pattern mayInstanceOfEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Synchronization class".
 */
private pattern mustInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Synchronization class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Synchronization class");
}

/**
 * An element may be an instance of type "Synchronization class".
 */
private pattern mayInstanceOfSynchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSynchronization_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSynchronization_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "State class".
 */
private pattern mustInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"State class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"State class");
}

/**
 * An element may be an instance of type "State class".
 */
private pattern mayInstanceOfState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularState class".
 */
private pattern mustInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularState class");
}

/**
 * An element may be an instance of type "RegularState class".
 */
private pattern mayInstanceOfRegularState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularState_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "CompositeElement class".
 */
private pattern mustInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"CompositeElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"CompositeElement class");
}

/**
 * An element may be an instance of type "CompositeElement class".
 */
private pattern mayInstanceOfCompositeElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
	neg find scopeDisallowsNewCompositeElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCompositeElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Choice class".
 */
private pattern mustInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Choice class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewChoice_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Choice class");
}

/**
 * An element may be an instance of type "Choice class".
 */
private pattern mayInstanceOfChoice_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewChoice_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfChoice_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Exit class".
 */
private pattern mustInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Exit class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExit_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Exit class");
}

/**
 * An element may be an instance of type "Exit class".
 */
private pattern mayInstanceOfExit_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExit_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExit_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "FinalState class".
 */
private pattern mustInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"FinalState class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"FinalState class");
}

/**
 * An element may be an instance of type "FinalState class".
 */
private pattern mayInstanceOfFinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find scopeDisallowsNewFinalState_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfFinalState_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []incomingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incomingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationincomingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,target,_);
	numberOfExistingOppositeReferences != 1;
} or {
	find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoingTransitions reference Vertex(source,target)
 */
private pattern mustInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoingTransitions reference Vertex");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoingTransitions reference Vertex(source,target)
 */
private pattern mayInRelationoutgoingTransitions_reference_Vertex(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVertex_class(problem,interpretation,source);
	find mayInstanceOfTransition_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference to the target,
	// the upper bound of the opposite reference multiplicity should be considered.
	numberOfExistingOppositeReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,target,_);
	numberOfExistingOppositeReferences != 1;
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []vertices reference Region(source,target)
 */
private pattern mustInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"vertices reference Region");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>vertices reference Region(source,target)
 */
private pattern mayInRelationvertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRegion_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvertices_reference_Region(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []target reference Transition(source,target)
 */
private pattern mustInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"target reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>target reference Transition(source,target)
 */
private pattern mayInRelationtarget_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,source,_);
	numberOfExistingReferences != 1;
} or {
	find mustInRelationtarget_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []source reference Transition(source,target)
 */
private pattern mustInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"source reference Transition");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>source reference Transition(source,target)
 */
private pattern mayInRelationsource_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfTransition_class(problem,interpretation,source);
	find mayInstanceOfVertex_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationsource_reference_Transition(problem,interpretation,source,_);
	numberOfExistingReferences != 1;
	// The eOpposite of the reference is containment, then a referene cannot be created if
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,source,_);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationsource_reference_Transition(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []regions reference CompositeElement(source,target)
 */
private pattern mustInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"regions reference CompositeElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>regions reference CompositeElement(source,target)
 */
private pattern mayInRelationregions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCompositeElement_class(problem,interpretation,source);
	find mayInstanceOfRegion_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern queries entryInRegion
private pattern mustInRelation_pattern_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	// var_r1 exported
	// var_e1 exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_e1);
}
private pattern mayInRelation_pattern_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	// var_r1 exported
	// var_e1 exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e1);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_r1,var_e1);
}
private pattern currentInRelation_pattern_queries_entryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1, var_e1)
{
	find interpretation(problem,interpretation);
	// var_r1 exported
	// var_e1 exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e1);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_r1,var_e1);
}
// Must, May and Current queries for pattern queries noEntryInRegion
private pattern mustInRelation_pattern_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	// var_r1 exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	neg find mayInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern mayInRelation_pattern_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	// var_r1 exported
	find mayInstanceOfRegion_class(problem,interpretation,var_r1);
	neg find mustInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
private pattern currentInRelation_pattern_queries_noEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find interpretation(problem,interpretation);
	// var_r1 exported
	find mustInstanceOfRegion_class(problem,interpretation,var_r1);
	neg find currentInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r1,_var__0);
}
// Must, May and Current queries for pattern queries multipleEntryInRegion
private pattern mustInRelation_pattern_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	// var_r exported
	find mustInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mustInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mayEquivalent(problem, interpretation, var_e1, var_e2);
}
private pattern mayInRelation_pattern_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	// var_r exported
	find mayInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find mayInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mustEquivalent(problem, interpretation, var_e1, var_e2);
}
private pattern currentInRelation_pattern_queries_multipleEntryInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find interpretation(problem,interpretation);
	// var_r exported
	find currentInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r,var_e1);
	find currentInRelation_pattern_queries_entryInRegion(problem,interpretation,var_r,var_e2);
	neg find mustEquivalent(problem, interpretation, var_e1, var_e2);
}
// Must, May and Current queries for pattern queries transition
private pattern mustInRelation_pattern_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_src exported
	// var_trg exported
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_trg);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
}
private pattern mayInRelation_pattern_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_src exported
	// var_trg exported
	find mayInRelationsource_reference_Transition(problem,interpretation,var_t,var_src);
	find mayInstanceOfVertex_class(problem,interpretation,var_src);
	find mayInRelationtarget_reference_Transition(problem,interpretation,var_t,var_trg);
	find mayInstanceOfVertex_class(problem,interpretation,var_trg);
}
private pattern currentInRelation_pattern_queries_transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_src, var_trg)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_src exported
	// var_trg exported
	find mustInRelationsource_reference_Transition(problem,interpretation,var_t,var_src);
	find mustInstanceOfVertex_class(problem,interpretation,var_src);
	find mustInRelationtarget_reference_Transition(problem,interpretation,var_t,var_trg);
	find mustInstanceOfVertex_class(problem,interpretation,var_trg);
}
// Must, May and Current queries for pattern queries incomingToEntry
private pattern mustInRelation_pattern_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_e exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelation_pattern_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern mayInRelation_pattern_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_e exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelation_pattern_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
private pattern currentInRelation_pattern_queries_incomingToEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_e exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find currentInRelation_pattern_queries_transition(problem,interpretation,var_t,_var__0,var_e);
}
// Must, May and Current queries for pattern queries noOutgoingTransitionFromEntry
private pattern mustInRelation_pattern_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	// var_e exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	neg find mayInRelation_pattern_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern mayInRelation_pattern_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	// var_e exported
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	neg find mustInRelation_pattern_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
private pattern currentInRelation_pattern_queries_noOutgoingTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find interpretation(problem,interpretation);
	// var_e exported
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	neg find currentInRelation_pattern_queries_transition(problem,interpretation,_var__0,var_e,_var__1);
}
// Must, May and Current queries for pattern queries multipleTransitionFromEntry
private pattern mustInRelation_pattern_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	// var_e exported
	// var_t1 exported
	// var_t2 exported
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t2);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	neg find mayEquivalent(problem, interpretation, var_t1, var_t2);
}
private pattern mayInRelation_pattern_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	// var_e exported
	// var_t1 exported
	// var_t2 exported
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t1);
	find mayInstanceOfTransition_class(problem,interpretation,var_t1);
	find mayInstanceOfEntry_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t2);
	find mayInstanceOfTransition_class(problem,interpretation,var_t2);
	neg find mustEquivalent(problem, interpretation, var_t1, var_t2);
}
private pattern currentInRelation_pattern_queries_multipleTransitionFromEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find interpretation(problem,interpretation);
	// var_e exported
	// var_t1 exported
	// var_t2 exported
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t1);
	find mustInstanceOfTransition_class(problem,interpretation,var_t1);
	find mustInstanceOfEntry_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t2);
	find mustInstanceOfTransition_class(problem,interpretation,var_t2);
	neg find mustEquivalent(problem, interpretation, var_t1, var_t2);
}
// Must, May and Current queries for pattern queries outgoingFromExit
private pattern mustInRelation_pattern_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_e exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
}
private pattern mayInRelation_pattern_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_e exported
	find mayInstanceOfExit_class(problem,interpretation,var_e);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
}
private pattern currentInRelation_pattern_queries_outgoingFromExit(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_e exported
	find mustInstanceOfExit_class(problem,interpretation,var_e);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_e,var_t);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
}
// Must, May and Current queries for pattern queries outgoingFromFinal
private pattern mustInRelation_pattern_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_f exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_t);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
}
private pattern mayInRelation_pattern_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_f exported
	find mayInstanceOfFinalState_class(problem,interpretation,var_f);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_t);
	find mayInstanceOfTransition_class(problem,interpretation,var_t);
}
private pattern currentInRelation_pattern_queries_outgoingFromFinal(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find interpretation(problem,interpretation);
	// var_t exported
	// var_f exported
	find mustInstanceOfFinalState_class(problem,interpretation,var_f);
	find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,var_f,var_t);
	find mustInstanceOfTransition_class(problem,interpretation,var_t);
}
// Must, May and Current queries for pattern queries noStateInRegion
private pattern mustInRelation_pattern_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	// var_region exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	neg find mayInRelation_pattern_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern mayInRelation_pattern_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	// var_region exported
	find mayInstanceOfRegion_class(problem,interpretation,var_region);
	neg find mustInRelation_pattern_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
private pattern currentInRelation_pattern_queries_noStateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find interpretation(problem,interpretation);
	// var_region exported
	find mustInstanceOfRegion_class(problem,interpretation,var_region);
	neg find currentInRelation_pattern_queries_StateInRegion(problem,interpretation,var_region,_var__0);
}
// Must, May and Current queries for pattern queries StateInRegion
private pattern mustInRelation_pattern_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	// var_region exported
	// var_state exported
	find mustInstanceOfState_class(problem,interpretation,var_state);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_state);
}
private pattern mayInRelation_pattern_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	// var_region exported
	// var_state exported
	find mayInstanceOfState_class(problem,interpretation,var_state);
	find mayInRelationvertices_reference_Region(problem,interpretation,var_region,var_state);
}
private pattern currentInRelation_pattern_queries_StateInRegion(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_region, var_state)
{
	find interpretation(problem,interpretation);
	// var_region exported
	// var_state exported
	find mustInstanceOfState_class(problem,interpretation,var_state);
	find mustInRelationvertices_reference_Region(problem,interpretation,var_region,var_state);
}
// Must, May and Current queries for pattern queries choiceHasNoOutgoing
private pattern mustInRelation_pattern_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	// var_c exported
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	neg find mayInRelation_pattern_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern mayInRelation_pattern_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	// var_c exported
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	neg find mustInRelation_pattern_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
private pattern currentInRelation_pattern_queries_choiceHasNoOutgoing(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	// var_c exported
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	neg find currentInRelation_pattern_queries_transition(problem,interpretation,_var__0,var_c,_var__1);
}
// Must, May and Current queries for pattern queries choiceHasNoIncoming
private pattern mustInRelation_pattern_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	// var_c exported
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	neg find mayInRelation_pattern_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern mayInRelation_pattern_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	// var_c exported
	find mayInstanceOfChoice_class(problem,interpretation,var_c);
	neg find mustInRelation_pattern_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}
private pattern currentInRelation_pattern_queries_choiceHasNoIncoming(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find interpretation(problem,interpretation);
	// var_c exported
	find mustInstanceOfChoice_class(problem,interpretation,var_c);
	neg find currentInRelation_pattern_queries_transition(problem,interpretation,_var__0,_var__1,var_c);
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,source,target); }or
	
	{ find mustInRelationvertices_reference_Region(problem,interpretation,source,target); }or
	
	{ find mustInRelationregions_reference_CompositeElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find mustInRelation_pattern_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern invalidatedBy_pattern_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find mustInRelation_pattern_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern invalidatedBy_pattern_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find mustInRelation_pattern_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern invalidatedBy_pattern_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find mustInRelation_pattern_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern invalidatedBy_pattern_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find mustInRelation_pattern_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern invalidatedBy_pattern_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find mustInRelation_pattern_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern invalidatedBy_pattern_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find mustInRelation_pattern_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern invalidatedBy_pattern_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern invalidatedBy_pattern_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find mustInRelation_pattern_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
private pattern existingMultiplicity_outgoingTransitions_reference_Vertex(problem:LogicProblem, interpretation:PartialInterpretation, object:DefinedElement, numberOfExistingReferences:java Integer) {
	find interpretation(problem,interpretation);
	find mustExist(problem,interpretation,object);
	find mustInstanceOfVertex_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,object,_);
}


private pattern existingMultiplicity_vertices_reference_Region(problem:LogicProblem, interpretation:PartialInterpretation, object:DefinedElement, numberOfExistingReferences:java Integer) {
	find interpretation(problem,interpretation);
	find mustExist(problem,interpretation,object);
	find mustInstanceOfRegion_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvertices_reference_Region(problem,interpretation,object,_);
}


private pattern existingMultiplicity_target_reference_Transition(problem:LogicProblem, interpretation:PartialInterpretation, object:DefinedElement, numberOfExistingReferences:java Integer) {
	find interpretation(problem,interpretation);
	find mustExist(problem,interpretation,object);
	find mustInstanceOfTransition_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationtarget_reference_Transition(problem,interpretation,object,_);
}


private pattern existingMultiplicity_regions_reference_CompositeElement(problem:LogicProblem, interpretation:PartialInterpretation, object:DefinedElement, numberOfExistingReferences:java Integer) {
	find interpretation(problem,interpretation);
	find mustExist(problem,interpretation,object);
	find mustInstanceOfCompositeElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationregions_reference_CompositeElement(problem,interpretation,object,_);
}



//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_queries_noEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r1)
{
	find currentInRelation_pattern_queries_noEntryInRegion(problem,interpretation,var_r1);
}
pattern unfinishedBy_pattern_queries_multipleEntryInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_r)
{
	find currentInRelation_pattern_queries_multipleEntryInRegion(problem,interpretation,var_r);
}
pattern unfinishedBy_pattern_queries_incomingToEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_queries_incomingToEntry(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_queries_noOutgoingTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e)
{
	find currentInRelation_pattern_queries_noOutgoingTransitionFromEntry(problem,interpretation,var_e);
}
pattern unfinishedBy_pattern_queries_multipleTransitionFromEntry(problem:LogicProblem, interpretation:PartialInterpretation,
	var_e, var_t1, var_t2)
{
	find currentInRelation_pattern_queries_multipleTransitionFromEntry(problem,interpretation,var_e,var_t1,var_t2);
}
pattern unfinishedBy_pattern_queries_outgoingFromExit(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_e)
{
	find currentInRelation_pattern_queries_outgoingFromExit(problem,interpretation,var_t,var_e);
}
pattern unfinishedBy_pattern_queries_outgoingFromFinal(problem:LogicProblem, interpretation:PartialInterpretation,
	var_t, var_f)
{
	find currentInRelation_pattern_queries_outgoingFromFinal(problem,interpretation,var_t,var_f);
}
pattern unfinishedBy_pattern_queries_noStateInRegion(problem:LogicProblem, interpretation:PartialInterpretation,
	var_region)
{
	find currentInRelation_pattern_queries_noStateInRegion(problem,interpretation,var_region);
}
pattern unfinishedBy_pattern_queries_choiceHasNoOutgoing(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_queries_choiceHasNoOutgoing(problem,interpretation,var_c);
}
pattern unfinishedBy_pattern_queries_choiceHasNoIncoming(problem:LogicProblem, interpretation:PartialInterpretation,
	var_c)
{
	find currentInRelation_pattern_queries_choiceHasNoIncoming(problem,interpretation,var_c);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfVertex_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegion_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExit_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatechart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfTransition_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSynchronization_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPseudostate_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfChoice_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCompositeElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfFinalState_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_FinalState_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_FinalState_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"FinalState class");
	find mayInstanceOfFinalState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Choice_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Choice class");
	find mayInstanceOfChoice_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Synchronization_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Synchronization class");
	find mayInstanceOfSynchronization_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class_by_regions_reference_CompositeElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"regions reference CompositeElement");
	find mustInstanceOfCompositeElement_class(problem,interpretation,container);
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayInRelationregions_reference_CompositeElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Region_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Region class");
	find mayInstanceOfRegion_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_State_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"State class");
	find mayInstanceOfState_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Exit_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Exit class");
	find mayInstanceOfExit_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class_by_outgoingTransitions_reference_Vertex_with_source_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, inverseInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"outgoingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,inverseInterpretation);
	PartialRelationInterpretation.interpretationOf.name(inverseInterpretation,"source reference Transition");
	find mustInstanceOfVertex_class(problem,interpretation,container);
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayInRelationoutgoingTransitions_reference_Vertex(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Transition_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Transition class");
	find mayInstanceOfTransition_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statechart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statechart class");
	find mayInstanceOfStatechart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class_by_vertices_reference_Region(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"vertices reference Region");
	find mustInstanceOfRegion_class(problem,interpretation,container);
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayInRelationvertices_reference_Region(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Entry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Entry class");
	find mayInstanceOfEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_FinalState_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
}
pattern refineTypeTo_Choice_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Synchronization_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Region_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
}
pattern refineTypeTo_State_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfFinalState_class(problem,interpretation,element);
	neg find mustInstanceOfPseudostate_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfState_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
}
pattern refineTypeTo_Exit_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Transition_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
}
pattern refineTypeTo_Statechart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatechart_class(problem,interpretation,element);
	neg find mustInstanceOfVertex_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfStatechart_class(problem,interpretation,element);
}
pattern refineTypeTo_Entry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSynchronization_class(problem,interpretation,element);
	neg find mustInstanceOfChoice_class(problem,interpretation,element);
	neg find mustInstanceOfRegularState_class(problem,interpretation,element);
	neg find mustInstanceOfRegion_class(problem,interpretation,element);
	neg find mustInstanceOfCompositeElement_class(problem,interpretation,element);
	neg find mustInstanceOfExit_class(problem,interpretation,element);
	neg find mustInstanceOfTransition_class(problem,interpretation,element);
	neg find mustInstanceOfEntry_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_incomingTransitions_reference_Vertex_and_target_reference_Transition(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation, oppositeInterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incomingTransitions reference Vertex");
	PartialInterpretation.partialrelationinterpretation(interpretation,oppositeInterpretation);
	PartialRelationInterpretation.interpretationOf.name(oppositeInterpretation,"target reference Transition");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVertex_class(problem,interpretation,from);
	find mustInstanceOfTransition_class(problem,interpretation,to);
	find mayInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
	neg find mustInRelationincomingTransitions_reference_Vertex(problem,interpretation,from,to);
}


//////////
// 5 Hints
//////////

//////////
// 6 Unit Propagations
//////////

// Collected propagation preconditions:


